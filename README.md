# JavaNotes

1. 类的内部封装了成员变量、构造方法和成员方法。
   
   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/5c1e4efe-aeba-454d-9883-320a2a64038f)
   
2. 实例化是指使用已经定义好的类，创建该类对象的过程。
   
   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/c9f3217a-2a5f-4dab-9c67-332c6296c176)

3. 抽象类不能被实例化，只能被继承。抽象类可以包含非抽象方法和属性，但至少要有一个抽象方法。抽象方法是一种没有实现的方法，只有定义，需要在子类中被实现。
   -抽象类的定义：

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/209785da-5daf-4f60-827b-4914282ba6ef)

   抽象类的实现（如果一个类继承了一个抽象类，那么它必须实现父类中的所有抽象方法）（在子类中实现抽象方法时需要使用@Override注解）：

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/f81f6325-e081-4733-9bd9-623cee45813e)


4. 接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。
   
   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/da2f4252-1c5a-4767-844c-53662ed00a5b)

5. 非抽象子类在实现接口时：
     -必须重写接口中所有抽象方法（所以，接口的抽象方法不能是 private、protected 或者 final）.
     -继承了接口的默认方法，即可以直接调用，也可以重写。
   接口中静态方法与.class 文件相关，所以只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用（静态方法和静态变量直属类，需直接通过类名调用）

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/d963a4ef-2999-4db5-8fd2-c223c675f35c)


6. 由于有了默认方法和静态方法，所以当两个默认方法或者静态方法包含一段相同的代码实现时，为了避免重复写该段代码，可以将其抽出来作为接口的私有方法。
   此外，对象的某些方法或者称为函数只想在对象的内部被使用，但不想在外部被访问到这些方法或函数，在此时也可以使用私有方法。 
 
   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/6c730bbc-2cd6-4c56-ba0b-de29f7fbea04)

7. Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/baadb86f-fbce-4eb1-8a71-8c4ff222960f)

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/2734f98a-be33-4871-bd10-5c100a92ff3d)

8. 多态是指两个子类继承同一个父类，并分别重写父类中的同一个方法。可以通过继承（extends）的关系实现，也可以通过接口的形式实现。

  ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/a5f1a298-1292-4c48-871c-d91780e6f6d7)


9. Java设计模式的六大设计原则： -单一职责原则：一个类或者一个方法就应该干一件事情。  -开闭原则：对象应该对扩展开放，对修改关闭，来使系统灵活和稳定。  -里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 -依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象，也就是说将扩展通过多态的方式扩展。   -接口隔离原则：一个接口只干一件事。  -迪米特原则：一个类应该保持对其它对象最少的了解，使得系统的功能模块功能更独立，也就是说多使用private。

10. 工厂模式（有多个工厂类，一个产品抽象类，工厂模式利用多态创建不同的产品对象，并使对象创建过程延迟到子类进行，不展示具体实现过程）：
   
   <img width="485" alt="屏幕截图 2024-02-20 064519" src="https://github.com/Jonas9172/JavaNotes/assets/105164575/9d7dceb5-b767-4ac9-a463-37ad27416295">

11. 抽象工厂模式（多个工厂类，多个产品抽象类）：

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/2a9dcd52-b520-4237-8a7a-cbaff4654d92)

12. 单例模式：在对象类中创造一个private的对象，设置为只能使用getInstance()外部调用，并将构造函数private，这样外部。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/34377278-6b2c-4381-8b3e-50ab1ab19d97)

13. 建造者模式： 用于构造内部复杂的对象。一个 Builder 类会更加关注零件装配的顺序，并一步一步构造最终的对象。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/53f9730a-7e20-4525-88bb-f025520255e9)

14. 原型模式：通过实现Cloneable接口，用于创建当前对象的克隆。 例如把对象的原型储存在hashtable中，在请求的时候返回它们的克隆，这能保证性能。 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的

15. 适配器模式：使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。假设有两个接口负责不同的功能，它们分别有自己的实体类，可以通过添加一个适配器类让一个实体类有另一个实体类功能。

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/6df1697b-603d-42b8-8126-373109a4a5d8)

16. 装饰器模式： 通过装饰器类向一个现有的对象添加新的功能，同时又不改变其结构。类似于Python里的装饰器。
17. 代理模式：通过代理类限制一个对象的功能。
18. 桥接模式： 通过实现一个接口的抽象类和实现类，将这个接口的实体对象的抽象性质分离并单独实现，来组成新的实体。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/e7b0c922-c4b4-4491-9d12-57f8fcc05457)

19. 组合模式：构造对象时为对象设置节点，以通过树形结构来表示这组对象的复杂关系。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/6062d995-fe6c-43fa-bedc-7bdb21128ad0)

20. 外观模式：设置一个外观类来将几个实现接口的实体类汇总到一起。可以通过外观类直接调用不同实体类的功能。
21. 享元模式：在工厂类中使用 HashMap 来存储对象，如果发现HashMap中有需要的对象，则返回该对象；如果没有，则创建这个对象并储存在HashMap中。主要用于减少创建对象的数量，以减少内存占用和提高性能。

22. 策略模式：定义一系列的算法并封装，以供后面选择和使用。
23. 模板模式：在抽象类中设置一个final的模板方法，它可以使得子类在不改变一个模板方法的结构的情况下，重定义该模板方法的某些特定步骤。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/da4b8392-1b75-401d-bf89-130f15d2b4a0)

24. 观察者模式：通过观察者类，检查一个对象的状态，如果状态改变，则更新所有依赖于它的对象。
25. 迭代器模式：提供一种方法，在不暴露该对象的内部表示的情况下，顺序访问一个聚合对象中各个元素。
26. 命令模式：将一个请求封装成一个对象，从而当需要使用特定的请求时，调用特定的对象，该对象将执行该请求。

27. 基本类型：byte，short，int，long，float，double，char，boolean；包装类型：将这些基本类型打包为对象的类。
    不同： 基本类型比较值用==；包装类型比较值用equals()； 基本类型为局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。 而包装类型会存放在堆中。
    装箱和拆箱：装箱就是将基础数据类型转换为对应的包装类型；拆箱就是将包装类型转换为对应的基础数据类型。

28. 浮点数精度丢失：在它转换为二进制过程中，无限循环的情况被截断了，造成丢失。  -解决方法：BigDecimal
29. 用long表示会溢出怎么办：使用BigInteger，原理是它内部使用了 int[] 数组来存储任意大小的整形数据。

30. 成员变量：可以被访问控制修饰符和static修饰，能被final修饰。存在于类中，如果被static修饰则属于类（被所有实例共享），如果没有被static修饰则属于实例，它们作为对象的一部分储存在堆中。有默认值。
    局部变量：不能被访问控制修饰符和static修饰，能被final修饰。存在于方法中，储存在栈中。无默认值。
31. 静态方法中不能调用非静态发方法：因为静态方法属于类，它可以随时通过类名被调用；而非静态方法属于实例，它只能在对象实例化后调用。如果静态方法中有非静态发方法的话，可能会因为调用不存在的静态成员而报错。
    
32. 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理. 注意：构造方法可以重载。
    重写就是子类对父类的允许访问的方法的实现过程进行重新编写。 注意：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

33. 面向对象三大特征：封装：把属性private，提供一些方法供外界操作或查看属性；继承：子类继承父类；多态：同一个接口，使用不同的实例而执行不同操作。此外，override和overload也是多态。

34. 接口和抽象类都不能被实例化。

35. String、StringBuffer、StringBuilder 都是字符串类型的类。效率：String < StringBuffer < StringBuilder。前两者多线程安全，后者多线程不安全。

36. Throwable是处理异常的类，Exception 和 Error 是它的子类。
37. Exception 和 Error 有什么区别：前者程序可以通过catch捕捉并处理；后者是真的错误。
38. Exception 分为 Checked Exception 和 Unchecked Exception，前者必须使用catch或throws处理才能通过编译，后者不处理也可以编译

39. 泛型：是一种通用型参数，可以用到类，接口，方法里。在实例化或者使用的时候需要提供一个具体化的对象类型，来让这个类，接口或方法只处理你想让它处理的对象类型。可以增强代码的可读性以及稳定性。

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/25801c47-d503-4995-834c-51248844ec15)

40. 反射机制：Java是先编译在运行，但是可能存在一些类，这些类的信息在程序运行时才能获得，这就需要程序在运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法，然后再运行。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。例如，这个程序可以在运行时获取自己的信息，在基于此做出操作。 框架和注解都依赖反射机制。

41. 注解用于修饰类，方法，变量。

42. SPI和API都是接口，不同的是SPI需要由调用者实现，API由实现方实现。

43.  Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。序列化协议属于 TCP/IP 协议应用层的一部分。对于不想进行序列化的变量，使用 transient 关键字修饰。

44.  Java IO流 根据数据的处理方式又分为字节流和字符流。

45.  






