# JavaNotes

1. 类的内部封装了成员变量、构造方法和成员方法。
   
   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/5c1e4efe-aeba-454d-9883-320a2a64038f)
   
2. 实例化是指使用已经定义好的类，创建该类对象的过程。
   
   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/c9f3217a-2a5f-4dab-9c67-332c6296c176)

3. 抽象类不能被实例化，只能被继承。抽象类可以包含非抽象方法和属性，但至少要有一个抽象方法。抽象方法是一种没有实现的方法，只有定义，需要在子类中被实现。
   -抽象类的定义：

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/209785da-5daf-4f60-827b-4914282ba6ef)

   抽象类的实现（如果一个类继承了一个抽象类，那么它必须实现父类中的所有抽象方法）（在子类中实现抽象方法时需要使用@Override注解）：

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/f81f6325-e081-4733-9bd9-623cee45813e)


4. 接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。
   
   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/da2f4252-1c5a-4767-844c-53662ed00a5b)

5. 非抽象子类在实现接口时：
     -必须重写接口中所有抽象方法（所以，接口的抽象方法不能是 private、protected 或者 final）.
     -继承了接口的默认方法，即可以直接调用，也可以重写。
   接口中静态方法与.class 文件相关，所以只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用（静态方法和静态变量直属类，需直接通过类名调用）

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/d963a4ef-2999-4db5-8fd2-c223c675f35c)


6. 由于有了默认方法和静态方法，所以当两个默认方法或者静态方法包含一段相同的代码实现时，为了避免重复写该段代码，可以将其抽出来作为接口的私有方法。
   此外，对象的某些方法或者称为函数只想在对象的内部被使用，但不想在外部被访问到这些方法或函数，在此时也可以使用私有方法。 
 
   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/6c730bbc-2cd6-4c56-ba0b-de29f7fbea04)

7. Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/baadb86f-fbce-4eb1-8a71-8c4ff222960f)

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/2734f98a-be33-4871-bd10-5c100a92ff3d)

8. 多态是指两个子类继承同一个父类，并分别重写父类中的同一个方法。可以通过继承（extends）的关系实现，也可以通过接口的形式实现。

  ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/a5f1a298-1292-4c48-871c-d91780e6f6d7)


9. Java设计模式的六大设计原则： -单一职责原则：一个类或者一个方法就应该干一件事情。  -开闭原则：对象应该对扩展开放，对修改关闭，来使系统灵活和稳定。  -里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 -依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象，也就是说将扩展通过多态的方式扩展。   -接口隔离原则：一个接口只干一件事。  -迪米特原则：一个类应该保持对其它对象最少的了解，使得系统的功能模块功能更独立，也就是说多使用private。

10. 工厂模式（有多个工厂类，一个产品抽象类，工厂模式利用多态创建不同的产品对象，并使对象创建过程延迟到子类进行，不展示具体实现过程）：
   
   <img width="485" alt="屏幕截图 2024-02-20 064519" src="https://github.com/Jonas9172/JavaNotes/assets/105164575/9d7dceb5-b767-4ac9-a463-37ad27416295">

11. 抽象工厂模式（多个工厂类，多个产品抽象类）：

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/2a9dcd52-b520-4237-8a7a-cbaff4654d92)

12. 单例模式：在对象类中创造一个private的对象，设置为只能使用getInstance()外部调用，并将构造函数private，这样外部。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/34377278-6b2c-4381-8b3e-50ab1ab19d97)

13. 建造者模式： 用于构造内部复杂的对象。一个 Builder 类会更加关注零件装配的顺序，并一步一步构造最终的对象。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/53f9730a-7e20-4525-88bb-f025520255e9)

14. 原型模式：通过实现Cloneable接口，用于创建当前对象的克隆。 例如把对象的原型储存在hashtable中，在请求的时候返回它们的克隆，这能保证性能。 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的

15. 适配器模式：使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。假设有两个接口负责不同的功能，它们分别有自己的实体类，可以通过添加一个适配器类让一个实体类有另一个实体类功能。

   ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/6df1697b-603d-42b8-8126-373109a4a5d8)

16. 装饰器模式： 通过装饰器类向一个现有的对象添加新的功能，同时又不改变其结构。类似于Python里的装饰器。
17. 代理模式：通过代理类限制一个对象的功能。
18. 桥接模式： 通过实现一个接口的抽象类和实现类，将这个接口的实体对象的抽象性质分离并单独实现，来组成新的实体。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/e7b0c922-c4b4-4491-9d12-57f8fcc05457)

19. 组合模式：构造对象时为对象设置节点，以通过树形结构来表示这组对象的复杂关系。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/6062d995-fe6c-43fa-bedc-7bdb21128ad0)

20. 外观模式：设置一个外观类来将几个实现接口的实体类汇总到一起。可以通过外观类直接调用不同实体类的功能。
21. 享元模式：在工厂类中使用 HashMap 来存储对象，如果发现HashMap中有需要的对象，则返回该对象；如果没有，则创建这个对象并储存在HashMap中。主要用于减少创建对象的数量，以减少内存占用和提高性能。

22. 策略模式：定义一系列的算法并封装，以供后面选择和使用。
23. 模板模式：在抽象类中设置一个final的模板方法，它可以使得子类在不改变一个模板方法的结构的情况下，重定义该模板方法的某些特定步骤。

    ![图片](https://github.com/Jonas9172/JavaNotes/assets/105164575/da4b8392-1b75-401d-bf89-130f15d2b4a0)

24. 观察者模式：通过观察者类，检查一个对象的状态，如果状态改变，则更新所有依赖于它的对象。
25. 迭代器模式：提供一种方法，在不暴露该对象的内部表示的情况下，顺序访问一个聚合对象中各个元素。
26. 命令模式：将一个请求封装成一个对象，从而当需要使用特定的请求时，调用特定的对象，该对象将执行该请求。


